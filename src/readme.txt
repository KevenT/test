1.策略模式(Strategy)
     定义算法，将他们分别封装起来，让他们可以相互替换，让算法变化对客户端透明。
2.观察者模式(Observer)
     解耦一系列对象的通知状态。定义对象之间的一对多依赖，当一端对象发生变换，通知多端。
3.装饰模式(Decorator)
     动态将责任附加到对象上。对扩展开放，对修改封闭。
4.工厂模式(Factory)
工厂方法：定义一个创建对象的接口，由子类实现这个接口决定怎样创建具体类。工厂方法把对象的创建延迟到子类。
抽象工厂：定义一个接口，用于创建相关或依赖对象的家族，而不明确指定具体类。
5.单例模式(Singleton)
     确保一个类只有一个实例，并且提供一个安全的全局访问点。
如果对多线程没有要求，可以直接在静态方法中创建。
如果存在资源竞争，采用“饿汉”方式创建。
如果jdk4之后，可有采用double checked locking
6.命令模式(Command)
     将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。
7.适配器模式(Adapter)
     改变一个接口成为一个客户端希望的样子。让原本不兼容的接口能够相互合作。
8.外观模式(Facade)
     简化系统接口，对客户端提供一个简单接口。
9.模板方法模式(Template Method)
     在方法中定义一个算法的骨架，而将一些步骤延迟到子类实现。使子类在不改变算法结构的情况下，重新定义算法的某些步骤。
10.迭代器模式(Iterator)
     提供一种方法顺序访问集合中的每个元素，而又不暴露其内部的表示。
11.组合模式(Composite)
     允许你将对象组成树形结构来表现“整体/部分”的层次结构。组合能让客户端以一致的方式处理个别对象和对象组合。
12.状态模式(State)
     允许对象内部状态改变时，改变它的行为，对象看起来就行修改了它的类。
13.代理模式(Proxy)
     为对象提供一个替身或者占位符来访问这个对象。
14.复合模式
     结合多个模式，组成一个解决方案。
          MVC中：
          M：观察者模式
          V：组合模式
